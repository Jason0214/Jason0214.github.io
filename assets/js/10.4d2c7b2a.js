(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{432:function(t,e,a){t.exports=a.p+"assets/img/profile-voluntary-context-switches-futex.b7020087.png"},433:function(t,e,a){t.exports=a.p+"assets/img/profile-voluntary-context-switches-strace.6924c84f.png"},434:function(t,e,a){t.exports=a.p+"assets/img/profile-voluntary-context-switches-gdb.c8aca413.png"},454:function(t,e,a){"use strict";a.r(e);var s=a(43),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("When running benchmarks in "),s("a",{attrs:{href:"https://github.com/roghnin/Interval-Based-Reclamation",target:"_blank",rel:"noopener noreferrer"}},[t._v("Interval-Based-Reclamation"),s("OutboundLink")],1),t._v(", I observed a suspicious "),s("strong",[t._v("Voluntary Context Switches")]),t._v(" increase using epoch based reclamation. I profiled the program and traced the context switches back to some mutexes in "),s("a",{attrs:{href:"https://github.com/jemalloc/jemalloc",target:"_blank",rel:"noopener noreferrer"}},[t._v("jemalloc"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"stat-process-with-time"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stat-process-with-time"}},[t._v("#")]),t._v(" Stat process with "),s("code",[t._v("time")])]),t._v(" "),s("p",[t._v("I was trying to measure the memory usage peak of different memory reclamation approaches "),s("strong",[t._v("NIL(no reclamation), HPBP(Hazard pointer based), and EBR(epoch based)")]),t._v(".\nI used "),s("a",{attrs:{href:"https://man7.org/linux/man-pages/man1/time.1.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("time")]),s("OutboundLink")],1),t._v(" to read system counters and get the memory consumption.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("LD_PRELOAD")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/usr/lib/libjemalloc.so /usr/bin/time -v ./bin/main "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("Note that "),s("a",{attrs:{href:"https://github.com/roghnin/Interval-Based-Reclamation",target:"_blank",rel:"noopener noreferrer"}},[t._v("Interval-Based-Reclamation"),s("OutboundLink")],1),t._v(" does not use any memory pools or arenas, so it is required to use "),s("a",{attrs:{href:"https://github.com/jemalloc/jemalloc",target:"_blank",rel:"noopener noreferrer"}},[t._v("jemalloc"),s("OutboundLink")],1),t._v(" to reduce page faults.")]),t._v(" "),s("p",[s("code",[t._v("/usr/bin/time")]),t._v(" shows context switch information aside from memory's maximal resident size.\nThey are all recorded in the following table.")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("ops/sec")]),t._v(" "),s("th",[t._v("Memory Peak(KB)")]),t._v(" "),s("th",[t._v("Minor (reclaiming a frame) page faults")]),t._v(" "),s("th",[t._v("Voluntary context switches")]),t._v(" "),s("th",[t._v("Involuntary context switches")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("NIL")]),t._v(" "),s("td",[t._v("31,118,761")]),t._v(" "),s("td",[t._v("10,660,544")]),t._v(" "),s("td",[t._v("238,047")]),t._v(" "),s("td",[t._v("2,997")]),t._v(" "),s("td",[t._v("3,284")])]),t._v(" "),s("tr",[s("td",[t._v("HPBR")]),t._v(" "),s("td",[t._v("7,091,661")]),t._v(" "),s("td",[t._v("554,064")]),t._v(" "),s("td",[t._v("76,372")]),t._v(" "),s("td",[t._v("1,035")]),t._v(" "),s("td",[t._v("3,186")])]),t._v(" "),s("tr",[s("td",[t._v("EBR")]),t._v(" "),s("td",[t._v("26,629,611")]),t._v(" "),s("td",[t._v("782,760")]),t._v(" "),s("td",[t._v("243,314")]),t._v(" "),s("td",[s("span",{staticStyle:{color:"red"}},[t._v("211,896")])]),t._v(" "),s("td",[t._v("3,169")])])])]),t._v(" "),s("p",[s("strong",[t._v("EBR")]),t._v(" reclamation has far more voluntary context switches than no reclamation(100x) and "),s("strong",[t._v("HPBR")]),t._v("(200x).")]),t._v(" "),s("h2",{attrs:{id:"source-of-voluntary-context-switches"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#source-of-voluntary-context-switches"}},[t._v("#")]),t._v(" Source of voluntary context switches")]),t._v(" "),s("p",[t._v("Voluntary context switches includes cases such as the process is waiting for an I/O operator to complete, the process triggers an fault, etc.")]),t._v(" "),s("p",[t._v("In running "),s("a",{attrs:{href:"https://github.com/roghnin/Interval-Based-Reclamation",target:"_blank",rel:"noopener noreferrer"}},[t._v("Interval-Based-Reclamation"),s("OutboundLink")],1),t._v(", each thread is pinned 1:1 onto cpu cores wth no I/O operations.\nFaults (e.g. page faults) are almost eliminated by using "),s("a",{attrs:{href:"https://github.com/jemalloc/jemalloc",target:"_blank",rel:"noopener noreferrer"}},[t._v("jemalloc"),s("OutboundLink")],1),t._v(" as well.\nTherefore, I suppose that these voluntary context switches are very likely coming from some syscalls.")]),t._v(" "),s("h2",{attrs:{id:"count-system-calls-with-perf"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#count-system-calls-with-perf"}},[t._v("#")]),t._v(" Count system calls with "),s("code",[t._v("perf")])]),t._v(" "),s("p",[t._v("In order to confirm the hypothesis that the "),s("strong",[t._v("EBR")]),t._v(" reclamation implementation somehow triggers a lot of syscalls, use "),s("code",[t._v("perf")]),t._v(" to count all the system calls.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("perf "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stat")]),t._v(" -e "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'syscalls:sys_enter_*'")]),t._v(" -p "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$PID")]),t._v("\n")])])]),s("p",[t._v("Result shows that "),s("a",{attrs:{href:"https://man7.org/linux/man-pages/man2/futex.2.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("futex")]),s("OutboundLink")],1),t._v(" has been continuously called.\n"),s("img",{attrs:{src:a(432),alt:"futex",loading:"lazy"}})]),t._v(" "),s("h2",{attrs:{id:"trace-system-calls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#trace-system-calls"}},[t._v("#")]),t._v(" Trace system calls")]),t._v(" "),s("p",[s("code",[t._v("strace")]),t._v(" can be used to show system calls as well.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strace")]),t._v(" --trace"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("futex -p "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$PID")]),t._v("\n")])])]),s("p",[t._v("From the trace, "),s("code",[t._v("futex")]),t._v(" is called from different PCs.\n"),s("img",{attrs:{src:a(433),alt:"futex",loading:"lazy"}})]),t._v(" "),s("h2",{attrs:{id:"stacktrace-the-system-call-with-gdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stacktrace-the-system-call-with-gdb"}},[t._v("#")]),t._v(" Stacktrace the system call with "),s("code",[t._v("gdb")])]),t._v(" "),s("p",[t._v("To identify the PC of "),s("code",[t._v("futex")]),t._v(", use "),s("code",[t._v("gdb")]),t._v(" to set a breakpoint on the "),s("code",[t._v("futex")]),t._v(" syscall.")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("(gdb) catch syscall futex\n")])])]),s("p",[t._v("One of the stack traces:\n"),s("img",{attrs:{src:a(434),alt:"gdb",loading:"lazy"}})]),t._v(" "),s("h2",{attrs:{id:"summary"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[t._v("#")]),t._v(" Summary")]),t._v(" "),s("p",[t._v("The observed voluntary context switches are coming from mutexes inside jemalloc.\nHowever, why and how it happens is still unknown, which may require a deeper understanding of the implementation of jemalloc and is out of the scope of this post.")]),t._v(" "),s("h2",{attrs:{id:"reference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[t._v("#")]),t._v(" Reference")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://stackoverflow.com/questions/37743596/gdb-catch-syscall-condition-and-string-comparisson",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://stackoverflow.com/questions/37743596/gdb-catch-syscall-condition-and-string-comparisson"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);
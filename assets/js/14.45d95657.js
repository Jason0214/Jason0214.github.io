(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{434:function(e,t,s){e.exports=s.p+"assets/img/cheatsheet-of-profiling-multi-core-systems-top-down.bb32df24.png"},458:function(e,t,s){"use strict";s.r(t);var a=s(43),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Cover some quick tools and some of my empirical approaches on profiling multi-core system.\n")]),e._v(" "),a("h2",{attrs:{id:"htop-cpu-utilizations-hyper-threading-cross-socket-and-memory-usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#htop-cpu-utilizations-hyper-threading-cross-socket-and-memory-usage"}},[e._v("#")]),e._v(" "),a("code",[e._v("htop")]),e._v(" - CPU utilizations, Hyper Threading, Cross Socket, and Memory Usage")]),e._v(" "),a("ul",[a("li",[e._v("CPU utilization of active cores should be close to 100%")]),e._v(" "),a("li",[e._v("User space CPU utilization should be close to 100%\n"),a("ul",[a("li",[e._v("if not, pay attention to syscalls and faults (e.g. page faults)")])])]),e._v(" "),a("li",[e._v("Normally no swap space should be used.")])]),e._v(" "),a("p",[e._v("Note that "),a("code",[e._v("htop")]),e._v(" only displays logical cores (identified by cpu_id) that might be hyper threads of physical cores.\nYou can not tell which logical cores are on the same physical core from the "),a("code",[e._v("htop")]),e._v(" panel.\n"),a("code",[e._v("htop")]),e._v(" does not show topology information such as "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/CPU_socket",target:"_blank",rel:"noopener noreferrer"}},[e._v("socket"),a("OutboundLink")],1),e._v(" either.")]),e._v(" "),a("p",[e._v("In order to get the core topology, check "),a("code",[e._v("/proc/cpuinfo")]),e._v(".\nAn example:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("cat")]),e._v(" /proc/cpuinfo\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("processor       : 0\nvendor_id       : GenuineIntel\ncpu family      : 6\nmodel           : 85\nmodel name      : Intel(R) Xeon(R) Gold 6252 CPU @ 2.10GHz\nstepping        : 7\nmicrocode       : 0x500002c\ncpu MHz         : 1057.852\ncache size      : 36608 KB\nphysical id     : 0\nsiblings        : 48\ncore id         : 0\ncpu cores       : 24\napicid          : 0\ninitial apicid  : 0\nfpu             : yes\nfpu_exception   : yes\ncpuid level     : 22\nwp              : yes\n...\n\nprocessor       : 1\nvendor_id       : GenuineIntel\ncpu family      : 6\nmodel           : 85\nmodel name      : Intel(R) Xeon(R) Gold 6252 CPU @ 2.10GHz\nstepping        : 7\nmicrocode       : 0x500002c\ncpu MHz         : 999.633\ncache size      : 36608 KB\nphysical id     : 1\nsiblings        : 48\ncore id         : 0\ncpu cores       : 24\n...\n")])])]),a("p",[e._v("There are other alternative commands that shows more compact and readable cpu info.\nFor example:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ lscpu --all --extended\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("CPU NODE SOCKET CORE L1d:L1i:L2:L3 ONLINE    MAXMHZ    MINMHZ\n  0    0      0    0 0:0:0:0          yes 3700.0000 1000.0000\n  1    1      1    1 1:1:1:1          yes 3700.0000 1000.0000\n  2    0      0    2 2:2:2:0          yes 3700.0000 1000.0000\n  3    1      1    3 3:3:3:1          yes 3700.0000 1000.0000\n  4    0      0    4 4:4:4:0          yes 3700.0000 1000.0000\n  5    1      1    5 5:5:5:1          yes 3700.0000 1000.0000\n  6    0      0    6 6:6:6:0          yes 3700.0000 1000.0000\n  7    1      1    7 7:7:7:1          yes 3700.0000 1000.0000\n  8    0      0    8 8:8:8:0          yes 3700.0000 1000.0000\n  9    1      1    9 9:9:9:1          yes 3700.0000 1000.0000\n 10    0      0   10 10:10:10:0       yes 3700.0000 1000.0000\n 11    1      1   11 11:11:11:1       yes 3700.0000 1000.0000\n 12    0      0   12 12:12:12:0       yes 3700.0000 1000.0000\n 13    1      1   13 13:13:13:1       yes 3700.0000 1000.0000\n 14    0      0   14 14:14:14:0       yes 3700.0000 1000.0000\n 15    1      1   15 15:15:15:1       yes 3700.0000 1000.0000\n 16    0      0   16 16:16:16:0       yes 3700.0000 1000.0000\n 17    1      1   17 17:17:17:1       yes 3700.0000 1000.0000\n 18    0      0   18 18:18:18:0       yes 3700.0000 1000.0000\n 19    1      1   19 19:19:19:1       yes 3700.0000 1000.0000\n 20    0      0   20 20:20:20:0       yes 3700.0000 1000.0000\n 21    1      1   21 21:21:21:1       yes 3700.0000 1000.0000\n 22    0      0   22 22:22:22:0       yes 3700.0000 1000.0000\n ...\n\n")])])]),a("h2",{attrs:{id:"usr-bin-time-memory-resident-size-and-context-switches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usr-bin-time-memory-resident-size-and-context-switches"}},[e._v("#")]),e._v(" "),a("code",[e._v("/usr/bin/time")]),e._v(" - Memory resident size, and  Context Switches.")]),e._v(" "),a("p",[e._v("Example of running "),a("code",[e._v("/usr/bin/time")]),e._v(" on "),a("code",[e._v("ls")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ /usr/bin/time -v "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('...\n\tCommand being timed: "ls"\n\tUser time (seconds): 0.00\n\tSystem time (seconds): 0.00\n\tPercent of CPU this job got: 100%\n\tElapsed (wall clock) time (h:mm:ss or m:ss): 0:00.00\n\tAverage shared text size (kbytes): 0\n\tAverage unshared data size (kbytes): 0\n\tAverage stack size (kbytes): 0\n\tAverage total size (kbytes): 0\n\tMaximum resident set size (kbytes): 1960\n\tAverage resident set size (kbytes): 0\n\tMajor (requiring I/O) page faults: 0\n\tMinor (reclaiming a frame) page faults: 83\n\tVoluntary context switches: 1\n\tInvoluntary context switches: 0\n\tSwaps: 0\n\tFile system inputs: 0\n\tFile system outputs: 0\n\tSocket messages sent: 0\n\tSocket messages received: 0\n\tSignals delivered: 0\n\tPage size (bytes): 4096\n\tExit status: 0\n')])])]),a("h2",{attrs:{id:"perf-cpu-cycles-cache-misses-and-more"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#perf-cpu-cycles-cache-misses-and-more"}},[e._v("#")]),e._v(" "),a("code",[e._v("perf")]),e._v(" - CPU Cycles, Cache Misses, and more.")]),e._v(" "),a("p",[e._v("Check the "),a("a",{attrs:{href:"https://perf.wiki.kernel.org/index.php/Main_Page",target:"_blank",rel:"noopener noreferrer"}},[e._v("wiki"),a("OutboundLink")],1),e._v(" for anything you need.")]),e._v(" "),a("h3",{attrs:{id:"perf-top"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#perf-top"}},[e._v("#")]),e._v(" "),a("code",[e._v("perf top")])]),e._v(" "),a("p",[a("code",[e._v("perf top")]),e._v(" shows 'realtime' perf data and is interactive.\nYou can step in a function on the panel and visualize the hotspots in the assembly code (with C/C++ symbol annotations).")]),e._v(" "),a("p",[e._v("Symbols of an optimized binary may not be very intuitive, nevertheless it helps locate hotspots into several lines of code.")]),e._v(" "),a("p",[e._v("If the annotation symbols are lost, double check compiler options to ensure that the binary is compiled with "),a("code",[e._v("-g")]),e._v(".\nYou can use "),a("code",[e._v("objdump -h a.out | tail")]),e._v(" to verify that symbols (segments with header prefixed by 'debug_') are present in the binary.")]),e._v(" "),a("h2",{attrs:{id:"top-down-analysis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#top-down-analysis"}},[e._v("#")]),e._v(" Top Down analysis")]),e._v(" "),a("p",[e._v("Top down analysis is the recommended way to profile processes on cores that have Out-of-order and Speculative Execution.\nMy understanding Top-down analysis counts the events from the hardware perspective, for example its top-level breakdown tracks "),a("code",[e._v("uops")]),e._v(" instead of branch mis-predictions and cache misses.")]),e._v(" "),a("p",[e._v("The hierarchical view:\n"),a("img",{attrs:{src:s(434),alt:"top-down",loading:"lazy"}})]),e._v(" "),a("p",[e._v("A detailed design introduction is available on the paper "),a("a",{attrs:{href:"https://ieeexplore.ieee.org/document/6844459",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Top-Down Method for Performance Analysis and Counters Architecture"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("Important DOs and DONTs:")]),e._v(" "),a("blockquote",[a("ol",[a("li",[e._v("A value of an inner node should be disregarded unless nodes on the path from the root to that particular node are all flagged.")]),e._v(" "),a("li",[e._v("Comparing fractions of non-sibling nodes is not recommended")])])]),e._v(" "),a("p",[e._v("Top down analysis can be applied through profilers such as VTune or more lightweight "),a("a",{attrs:{href:"https://github.com/andikleen/pmu-tools",target:"_blank",rel:"noopener noreferrer"}},[e._v("pmu-tools"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ ~/pmu-tools/toplev.py --force-cpu"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("skx --core S0-C0 -l3 -v --no-desc\n")])])]),a("h2",{attrs:{id:"flame-graph"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flame-graph"}},[e._v("#")]),e._v(" Flame Graph")]),e._v(" "),a("p",[e._v("TODO: "),a("a",{attrs:{href:"https://github.com/brendangregg/FlameGraph",target:"_blank",rel:"noopener noreferrer"}},[e._v("FlameGraph"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"off-cpu-analysis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#off-cpu-analysis"}},[e._v("#")]),e._v(" Off-CPU analysis")]),e._v(" "),a("p",[e._v("TODO: "),a("a",{attrs:{href:"https://github.com/iovisor/bcc",target:"_blank",rel:"noopener noreferrer"}},[e._v("bcc"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"memory-footprint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memory-footprint"}},[e._v("#")]),e._v(" Memory Footprint")]),e._v(" "),a("p",[e._v("TODO: "),a("a",{attrs:{href:"https://github.com/stefannoll/mat",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/stefannoll/mat"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("TODO: "),a("a",{attrs:{href:"https://dl.acm.org/doi/pdf/10.1145/3399666.3399896",target:"_blank",rel:"noopener noreferrer"}},[e._v("Analyzing Memory Accesses With Modern Processors"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[e._v("#")]),e._v(" Reference:")]),e._v(" "),a("ul",[a("li",[e._v("https://unix.stackexchange.com/questions/57920/how-do-i-know-which-processors-are-physical-cores")]),e._v(" "),a("li",[e._v("https://stackoverflow.com/questions/774556/peak-memory-usage-of-a-linux-unix-process")])])])}),[],!1,null,null,null);t.default=n.exports}}]);
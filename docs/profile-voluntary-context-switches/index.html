<!doctype html><html lang=en><head><meta charset=utf-8><meta content=no-referrer name=referrer><meta content="width=device-width,initial-scale=1.0,maximum-scale=5" name=viewport><title>Profile Voluntary Context Switches | Jiacheng's Mini Blog</title><meta content="Profile Voluntary Context Switches | Jiacheng's Mini Blog" property=og:title><meta content="Profile Voluntary Context Switches | Jiacheng's Mini Blog" name=twitter:title><meta content="When running benchmarks in Interval-Based-Reclamation, I observed a suspicious Voluntary Context Switches increase using epoch based reclamation. I profiled the program and traced the context switches back to some mutexes in jemalloc." name=description><meta content="When running benchmarks in Interval-Based-Reclamation, I observed a suspicious Voluntary Context Switches increase using epoch based reclamation. I profiled the program and traced the context switches back to some mutexes in jemalloc." property=og:description><meta content="When running benchmarks in Interval-Based-Reclamation, I observed a suspicious Voluntary Context Switches increase using epoch based reclamation. I profiled the program and traced the context switchesâ€¦" name=twitter:description><meta content="Jiacheng's Mini Blog" property=og:site_name><meta content=https://jason0214.github.io property=og:url><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://jason0214.github.io/base.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=https://jason0214.github.io/fontawesome/fontawesome.css rel=stylesheet><link href=https://jason0214.github.io/fontawesome/brands.css rel=stylesheet><link href=https://jason0214.github.io/fontawesome/solid.css rel=stylesheet><link href=https://jason0214.github.io/favicon.ico rel=icon type=image/x-icon><body><a class="skip-link p-screen-reader-text" href=#main>Skip to content</a><header class=l-header><h1 class="c-title p-title"><a class=p-title__link href=https://jason0214.github.io>Jiacheng's Mini Blog</a></h1><p class=p-subtitle>Less tech, more life</header><main class=l-main id=main><article class=p-article><header><h1>Profile Voluntary Context Switches</h1><div><div class=c-time><time datetime=" 2020-07-06"> 2020-07-06 </time> - (3 min read)</div></div></header><section class=p-article__body id=js-article><p>When running benchmarks in <a href=https://github.com/roghnin/Interval-Based-Reclamation>Interval-Based-Reclamation</a>, I observed a suspicious <strong>Voluntary Context Switches</strong> increase using epoch based reclamation. I profiled the program and traced the context switches back to some mutexes in <a href=https://github.com/jemalloc/jemalloc>jemalloc</a>.</p><span id=continue-reading></span><h2 id=stat-process-with-time>Stat process with <code>time</code><a aria-label="Anchor link for: stat-process-with-time" class=zola-anchor href=#stat-process-with-time><i class="fas fa-link"></i></a></h2><p>I was trying to measure the memory usage peak of different memory reclamation approaches <strong>NIL(no reclamation), HPBP(Hazard pointer based), and EBR(epoch based)</strong>. I used <a href=https://man7.org/linux/man-pages/man1/time.1.html><code>time</code></a> to read system counters and get the memory consumption.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>LD_PRELOAD</span><span>=</span><span style=color:#a3be8c>/usr/lib/libjemalloc.so </span><span style=color:#bf616a>/usr/bin/time -v</span><span> ./bin/main &lt;args>
</span></code></pre><p>Note that <a href=https://github.com/roghnin/Interval-Based-Reclamation>Interval-Based-Reclamation</a> does not use any memory pools or arenas, so it is required to use <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> to reduce page faults.<p><code>/usr/bin/time</code> shows context switch information aside from memory's maximal resident size. They are all recorded in the following table.<table><thead><tr><th><th>ops/sec<th>Memory Peak(KB)<th>Minor (reclaiming a frame) page faults<th>Voluntary context switches<th>Involuntary context switches<tbody><tr><td>NIL<td>31,118,761<td>10,660,544<td>238,047<td>2,997<td>3,284<tr><td>HPBR<td>7,091,661<td>554,064<td>76,372<td>1,035<td>3,186<tr><td>EBR<td>26,629,611<td>782,760<td>243,314<td><span style=color:red>211,896</span><td>3,169<tr><td><strong>EBR</strong> reclamation has far more voluntary context switches than no reclamation(100x) and <strong>HPBR</strong>(200x).<td><td><td><td><td></table><h2 id=source-of-voluntary-context-switches>Source of voluntary context switches<a aria-label="Anchor link for: source-of-voluntary-context-switches" class=zola-anchor href=#source-of-voluntary-context-switches><i class="fas fa-link"></i></a></h2><p>Voluntary context switches includes cases such as the process is waiting for an I/O operator to complete, the process triggers an fault, etc.<p>In running <a href=https://github.com/roghnin/Interval-Based-Reclamation>Interval-Based-Reclamation</a>, each thread is pinned 1:1 onto cpu cores wth no I/O operations. Faults (e.g. page faults) are almost eliminated by using <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> as well. Therefore, I suppose that these voluntary context switches are very likely coming from some syscalls.<h2 id=count-system-calls-with-perf>Count system calls with <code>perf</code><a aria-label="Anchor link for: count-system-calls-with-perf" class=zola-anchor href=#count-system-calls-with-perf><i class="fas fa-link"></i></a></h2><p>In order to confirm the hypothesis that the <strong>EBR</strong> reclamation implementation somehow triggers a lot of syscalls, use <code>perf</code> to count all the system calls.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>perf</span><span> stat</span><span style=color:#bf616a> -e </span><span>'</span><span style=color:#a3be8c>syscalls:sys_enter_*</span><span>'</span><span style=color:#bf616a> -p </span><span>$</span><span style=color:#bf616a>PID
</span></code></pre><p>Result shows that <a href=https://man7.org/linux/man-pages/man2/futex.2.html><code>futex</code></a> has been continuously called. <img alt=futex src=https://jason0214.github.io/profile-voluntary-context-switches/profile-voluntary-context-switches-futex.png><h2 id=trace-system-calls>Trace system calls<a aria-label="Anchor link for: trace-system-calls" class=zola-anchor href=#trace-system-calls><i class="fas fa-link"></i></a></h2><p><code>strace</code> can be used to show system calls as well.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>strace --trace</span><span>=futex</span><span style=color:#bf616a> -p </span><span>$</span><span style=color:#bf616a>PID
</span></code></pre><p>From the trace, <code>futex</code> is called from different PCs. <img alt=futex src=https://jason0214.github.io/profile-voluntary-context-switches/profile-voluntary-context-switches-strace.png><h2 id=stacktrace-the-system-call-with-gdb>Stacktrace the system call with <code>gdb</code><a aria-label="Anchor link for: stacktrace-the-system-call-with-gdb" class=zola-anchor href=#stacktrace-the-system-call-with-gdb><i class="fas fa-link"></i></a></h2><p>To identify the PC of <code>futex</code>, use <code>gdb</code> to set a breakpoint on the <code>futex</code> syscall.<pre style=color:#c0c5ce;background-color:#2b303b><code><span>(gdb) catch syscall futex
</span></code></pre><p>One of the stack traces: <img alt=gdb src=https://jason0214.github.io/profile-voluntary-context-switches/profile-voluntary-context-switches-gdb.png><h2 id=summary>Summary<a aria-label="Anchor link for: summary" class=zola-anchor href=#summary><i class="fas fa-link"></i></a></h2><p>The observed voluntary context switches are coming from mutexes inside jemalloc. However, why and how it happens is still unknown, which may require a deeper understanding of the implementation of jemalloc and is out of the scope of this post.<h2 id=reference>Reference<a aria-label="Anchor link for: reference" class=zola-anchor href=#reference><i class="fas fa-link"></i></a></h2><ul><li><a href=https://stackoverflow.com/questions/37743596/gdb-catch-syscall-condition-and-string-comparisson>https://stackoverflow.com/questions/37743596/gdb-catch-syscall-condition-and-string-comparisson</a></ul></section><footer><nav class="c-pagination p-pagination"><div class=c-pagination__ctrl><div class=c-pagination__newer></div><div class=c-pagination__older></div></div></nav></footer></article></main><footer class=l-footer><p class=p-copyright></footer>
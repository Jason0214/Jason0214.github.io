<!doctype html><html lang=en><head><meta charset=utf-8><meta content=no-referrer name=referrer><meta content="width=device-width,initial-scale=1.0,maximum-scale=5" name=viewport><title>Graphics and System Readings | Jiacheng's Mini Blog</title><meta content="Graphics and System Readings | Jiacheng's Mini Blog" property=og:title><meta content="Graphics and System Readings | Jiacheng's Mini Blog" name=twitter:title><meta content="Blogs and articles that I found interesting." name=description><meta content="Blogs and articles that I found interesting." property=og:description><meta content="Blogs and articles that I found interesting." name=twitter:description><meta content="Jiacheng's Mini Blog" property=og:site_name><meta content=https://jason0214.github.io property=og:url><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://jason0214.github.io/base.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=https://jason0214.github.io/fontawesome/fontawesome.css rel=stylesheet><link href=https://jason0214.github.io/fontawesome/brands.css rel=stylesheet><link href=https://jason0214.github.io/fontawesome/solid.css rel=stylesheet><link href=https://jason0214.github.io/favicon.ico rel=icon type=image/x-icon><body><a class="skip-link p-screen-reader-text" href=#main>Skip to content</a><header class=l-header><h1 class="c-title p-title"><a class=p-title__link href=https://jason0214.github.io>Jiacheng's Mini Blog</a></h1><p class=p-subtitle>Less tech, more life</header><main class=l-main id=main><article class=p-article><header><h1>Graphics and System Readings</h1><div><div class=c-time><time datetime=" 2021-04-07"> 2021-04-07 </time> - (14 min read)</div></div></header><section class=p-article__body id=js-article><p>Blogs and articles that I found interesting.</p><span id=continue-reading></span><p>[[toc]]<h3 id=the-mozilla-observatory-that-scan-your-site-to-find-vulnerabilities>The Mozilla Observatory that scan your site to find vulnerabilities<a aria-label="Anchor link for: the-mozilla-observatory-that-scan-your-site-to-find-vulnerabilities" class=zola-anchor href=#the-mozilla-observatory-that-scan-your-site-to-find-vulnerabilities><i class="fas fa-link"></i></a></h3><p>https://observatory.mozilla.org/<h3 id=after-working-at-google-i-ll-never-let-myself-love-a-job>"After Working at Google, I’ll Never Let Myself Love a Job"<a aria-label="Anchor link for: after-working-at-google-i-ll-never-let-myself-love-a-job" class=zola-anchor href=#after-working-at-google-i-ll-never-let-myself-love-a-job><i class="fas fa-link"></i></a></h3><p><a href=https://web.archive.org/web/20210731125322/https://www.nytimes.com/2021/04/07/opinion/google-job-harassment.html>https://web.archive.org/web/20210731125322/https://www.nytimes.com/2021/04/07/opinion/google-job-harassment.html</a><p>I had spent six months doing two internship at Google. This article reminds me how I still love the time I spent there. The most part of the reason is that Google takes good care of everything and you only need to focus on your work. I got great food, easy commute, and all kind of social/physical benefits (I run full court basketball three times a week at weekdays and spent every weekend hiking with my co-workers LOL). Indeed it is "structured my life around my job".<p>Now, I work for a company pays less and provides far little benefits. The only better part is that I have more interesting things to work on than what I did at Google. But I still enjoy the work not a bit less. In the end, it is the work that matters. Other benefits are actually easy to get in normal life, for example by having a family. By cut off my life from my work, I think I have a much healthier work experience than the Google days.<h3 id=query-engines-push-vs-pull>Query Engines: Push vs. Pull<a aria-label="Anchor link for: query-engines-push-vs-pull" class=zola-anchor href=#query-engines-push-vs-pull><i class="fas fa-link"></i></a></h3><p><a href=http://justinjaffray.com/query-engines-push-vs.-pull/>http://justinjaffray.com/query-engines-push-vs.-pull/</a><p>I had spent some time working on a query optimizer when doing database system research. At that time, all the lab people believe Push based execution is a clear win. Not limit to cache efficiency, the data can even be kept entirely in registers if the operation footprint is small as mentioned in Thomas Neumann's paper.<p>Still the shortcoming of the Push based execution mentioned in the article is valid. In merge join, Push based model may need to materialize more data than necessary. Though I fail to see how LIMIT alone can create problems for Push based model. I may need to spend some to read Shaikhha's paper :)<h3 id=branch-predictor-how-many-if-s-are-too-many-including-x86-and-m1-benchmarks>Branch predictor: How many "if"s are too many? Including x86 and M1 benchmarks!<a aria-label="Anchor link for: branch-predictor-how-many-if-s-are-too-many-including-x86-and-m1-benchmarks" class=zola-anchor href=#branch-predictor-how-many-if-s-are-too-many-including-x86-and-m1-benchmarks><i class="fas fa-link"></i></a></h3><p><a href=https://blog.cloudflare.com/branch-predictor/>https://blog.cloudflare.com/branch-predictor/</a><p>Got to know the performance impact of Branch Target Buffer for the first time. Great writeup. Good experiments and analysis.<h3 id=how-i-learned-to-love-tail-calls-in-c>How I Learned To Love Tail Calls in C<a aria-label="Anchor link for: how-i-learned-to-love-tail-calls-in-c" class=zola-anchor href=#how-i-learned-to-love-tail-calls-in-c><i class="fas fa-link"></i></a></h3><p><a href=https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.htmlQ>https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.htmlQ</a><blockquote><p>Theoretically, this control flow graph paired with a profile should give the compiler all of the information it needs to generate the most optimal code. In practice, when a function is this big and connected, we often find ourselves fighting the compiler. It spills an important variable when we want it to keep it in a register. It hoists stack frame manipulation that we want to shrink wrap around a fallback function invocation. It merges identical code paths that we wanted to keep separate for branch prediction reasons.</blockquote><p>Better optimized code are generated by compiler when rewrite a switch case with a chain of tail calls? Great writeup.<h3 id=brendan-gregg-s-blog-usenix-lisa2021-computing-performance-on-the-horizon>Brendan Gregg's Blog - USENIX LISA2021 Computing Performance: On the Horizon<a aria-label="Anchor link for: brendan-gregg-s-blog-usenix-lisa2021-computing-performance-on-the-horizon" class=zola-anchor href=#brendan-gregg-s-blog-usenix-lisa2021-computing-performance-on-the-horizon><i class="fas fa-link"></i></a></h3><p><a href=https://brendangregg.com/blog/2021-07-05/computing-performance-on-the-horizon.html>https://brendangregg.com/blog/2021-07-05/computing-performance-on-the-horizon.html</a><p>My key takeaways: NUMA architecture would die?<h3 id=modern-microprocessors-a-90-minute-guide>Modern Microprocessors - A 90-Minute Guide!<a aria-label="Anchor link for: modern-microprocessors-a-90-minute-guide" class=zola-anchor href=#modern-microprocessors-a-90-minute-guide><i class="fas fa-link"></i></a></h3><p><a href=http://www.lighterra.com/papers/modernmicroprocessors/>http://www.lighterra.com/papers/modernmicroprocessors/</a><ul><li>"Register Renaming & OOO"</ul><blockquote><p>RISC, software register renaming versus hardware renaming</blockquote><ul><li><p>"The Brainiac Debate"</p><li><p>"The Power Wall & The ILP Wall"</p></ul><blockquote><p>One of the most interesting members of the RISC-style x86 group was the Transmeta Crusoe processor, which translated x86 instructions into an internal VLIW form, rather than internal superscalar, and used software to do the translation at runtime, much like a Java virtual machine. This approach allowed the processor itself to be a simple VLIW, without the complex x86 decoding and register-renaming hardware of decoupled x86 designs, and without any superscalar dispatch or OOO logic either. The software-based x86 translation did reduce the system's performance compared to hardware translation (which occurs as additional pipeline stages and thus is almost free in performance terms), but the result was a very lean chip which ran fast and cool and used very little power. A 600 MHz Crusoe processor could match a then-current 500 MHz Pentium III running in its low-power mode (300 MHz clock speed) while using only a fraction of the power and generating only a fraction of the heat. This made it ideal for laptops and handheld computers, where battery life is crucial. Today, of course, x86 processor variants designed specifically for low power use, such as the Pentium M and its Core descendants, have made the Transmeta-style software-based approach unnecessary, although a very similar approach is currently being used in NVIDIA's Denver ARM processors, again in the quest for high performance at very low power.</blockquote><ul><li>"More Cores or Wider Cores?"<br> cost of OOO SMT area</ul><blockquote><p>but the maximum outright single-threaded performance of large cores, perhaps in the future we might see asymmetric designs, with one or two big, wide, brainiac cores plus a large number of smaller, narrower, simpler cores. In many ways, such a design makes the most sense – highly parallel programs would benefit from the many small cores more than a few large ones, but single-threaded, sequential programs want the might of at least one large, wide, brainiac core, even if it does take four times the area to provide only twice the single-threaded performance.</blockquote><p>Amazing article from beginning to end. Literally spent more than two hours reading it.<h3 id=introduction-to-open-source-private-lte-and-5g-networks>Introduction to open source private LTE and 5G networks<a aria-label="Anchor link for: introduction-to-open-source-private-lte-and-5g-networks" class=zola-anchor href=#introduction-to-open-source-private-lte-and-5g-networks><i class="fas fa-link"></i></a></h3><p><a href=https://ubuntu.com/blog/introduction-to-open-source-private-lte-and-5g-networks>https://ubuntu.com/blog/introduction-to-open-source-private-lte-and-5g-networks</a><p>Very attractive stack. It is safer than Wifi and probably more suitable to create a more secure smart home setup. But looks like you may need to license it ??<p>Some comments from HackerNews discussion:<blockquote><p>I'd love to setup a small scale network for personal use, but the elephant in the room is licensing.... Is it actually possible to formally license a DIY LTE network? (Or AMPS, 2G, 3G). In the UK, for example it is possible to get experimental licenses in principle, but I doubt it would be possible for an individual to legally operate a permanent or long term network on/near commercially allocated frequencies? You need to put a custom SIM into every device, and set up a PLMN identity for the network, which is just a 5 or 6 digit number that identifies the network to handsets. The SIM tells the phone what network it should try to join, and contains the crypto keys used to do authentication with the network. You can often get a PLMN allocated by your national telecoms regulator, or use one in the 999/xx range, which are set aside for private, uncoordinated use.</blockquote><h3 id=linear-interpolation-in-frequency-domain>linear interpolation in frequency domain<a aria-label="Anchor link for: linear-interpolation-in-frequency-domain" class=zola-anchor href=#linear-interpolation-in-frequency-domain><i class="fas fa-link"></i></a></h3><p><a href=http://conf.uni-obuda.hu/cinti2009/54_cinti2009_submission.pdf>http://conf.uni-obuda.hu/cinti2009/54_cinti2009_submission.pdf</a> I had joined a computer graphics basic knowledge training for new hires. It came across the texture filer and start wondering how effective the bilinear filter (the most common one) to reduce aliasing. Here it is in the frequency domain, bilinear interpolation is already a pretty good low pass filter. This paper includes the cubic interpolation as well. There is a comparison showing how much better the cubic one is.<h3 id=the-ultimate-guide-to-inflation>The Ultimate Guide to Inflation<a aria-label="Anchor link for: the-ultimate-guide-to-inflation" class=zola-anchor href=#the-ultimate-guide-to-inflation><i class="fas fa-link"></i></a></h3><p><a href=https://www.lynalden.com/inflation/>https://www.lynalden.com/inflation/</a><h3 id=banks-qe-and-money-printing>Banks, QE, and Money-Printing<a aria-label="Anchor link for: banks-qe-and-money-printing" class=zola-anchor href=#banks-qe-and-money-printing><i class="fas fa-link"></i></a></h3><p><a href=https://www.lynalden.com/money-printing/>https://www.lynalden.com/money-printing/</a><p>These two comes in a serial. Both are pretty good written. Actually some of the fact are easy to think through, for example the reason that the Great Financial Crisis (2008) does not cause big inflation. The fiscal authorities play together with the banks system is new to me. I also find that the microeconomic examples to show how loads/savings affect the broad money supply very interesting.<h3 id=software-reciprocal>Software reciprocal<a aria-label="Anchor link for: software-reciprocal" class=zola-anchor href=#software-reciprocal><i class="fas fa-link"></i></a></h3><p><a href=http://pvk.ca/Blog/LowLevel/software-reciprocal.html>http://pvk.ca/Blog/LowLevel/software-reciprocal.html</a><p>Very powerful optimization techniques. I think it falls into the category of numerical analysis. An IEEE float is composed of three parts, sign, exponents, and significand. When computing the reciprocal, simple taking the opposite value of exponents can give a pretty close approximation. However, it is not accurate enough to let the Newton method converge. Therefore, the author did more numerical analysis to find a magic number which produce a close enough reciprocal for any float number to subtract. It is much simpler and easier to understand than the "fast inverse square root".<h3 id=beating-the-l1-cache-with-value-speculation>Beating the L1 cache with value speculation<a aria-label="Anchor link for: beating-the-l1-cache-with-value-speculation" class=zola-anchor href=#beating-the-l1-cache-with-value-speculation><i class="fas fa-link"></i></a></h3><p><a href=https://mazzo.li/posts/value-speculation.html>https://mazzo.li/posts/value-speculation.html</a><p>Value dependency sometimes can be eliminated, good technique learned.<h3 id=the-stack-monoid-revisited>The stack monoid revisited<a aria-label="Anchor link for: the-stack-monoid-revisited" class=zola-anchor href=#the-stack-monoid-revisited><i class="fas fa-link"></i></a></h3><p><a href=https://raphlinus.github.io/gpu/2021/05/13/stack-monoid-revisited.html>https://raphlinus.github.io/gpu/2021/05/13/stack-monoid-revisited.html</a><p>A follow up on the stack monoid. To be honest, I does not fully understand the algorithm. It is a little cumbersome to read. But I kept trying to read it, because design a monoid for an algorithm to parallel it is probably a universal approach.<p>The key takeaways for the last read: <a href=https://en.wikipedia.org/wiki/Parallel_RAM>PRAM</a> could give a theoretical upper bound of parallelism.<h3 id=finding-windows-handle-leaks-in-chromium-and-others>Finding Windows HANDLE leaks, in Chromium and others<a aria-label="Anchor link for: finding-windows-handle-leaks-in-chromium-and-others" class=zola-anchor href=#finding-windows-handle-leaks-in-chromium-and-others><i class="fas fa-link"></i></a></h3><p>[https://randomascii.wordpress.com/2021/07/25/finding-windows-handle-leaks-in-chromium-and-others/] (https://randomascii.wordpress.com/2021/07/25/finding-windows-handle-leaks-in-chromium-and-others/)<p>Good writeup. I don't have much Windows experience. On Linux checking fd handles leak is much easier, but I am not aware of tool that can do a good visualization on it. WPA is pretty impressive.<p>Some funny comments from HackerNews:<blockquote><p>First thing I do on a new Windows setup is turn on "handles", "threads", "Commit size", "NP pool" columns in task manager details... If you want to see some real offenders... have a quick look at Asus's "LightingService.exe" (the daemon that controls their rgb LED coloring suite). Gets up to 2m+ handles after a day or two of running on my system.</blockquote><h3 id=the-night-watch>The Night Watch<a aria-label="Anchor link for: the-night-watch" class=zola-anchor href=#the-night-watch><i class="fas fa-link"></i></a></h3><p><a href=https://www.usenix.org/system/files/1311_05-08_mickens.pdf>https://www.usenix.org/system/files/1311_05-08_mickens.pdf</a><p>In case the title being misleading, it is actual an article from a system researcher talking about how "great" system researcher and developers are. To be honest, I don't like the attitude in this article that system people being superior than others. Though, it might just be some acceptable literary techniques.<p>I have to admit the languages are vivid and the metaphors are unique. IMO, it might be a good reference for managers in charge of a bunch of system people to quote some motivation slogans. And it might work well. System people are indeed "nerds" :)<h3 id=what-mrna-is-good-for-and-what-it-maybe-isn-t>What mRNA is Good For, And What It Maybe Isn’t<a aria-label="Anchor link for: what-mrna-is-good-for-and-what-it-maybe-isn-t" class=zola-anchor href=#what-mrna-is-good-for-and-what-it-maybe-isn-t><i class="fas fa-link"></i></a></h3><p><a href=https://blogs.sciencemag.org/pipeline/archives/2021/06/29/what-mrna-is-good-for-and-what-it-maybe-isnt>https://blogs.sciencemag.org/pipeline/archives/2021/06/29/what-mrna-is-good-for-and-what-it-maybe-isnt</a><p>Okay it is probably hard for mRNA find its place outside of vaccines :(<ol><li>Producing proteins from mRNA does not last, you have to keep receiving mRNA<li>Not trigger any immune response is hard (the opposite usage of vaccination)<li>Targeting is hard<li>We got several better alternatives than mRNA</ol><h3 id=visibility-buffer-rendering-with-material-graphs>Visibility Buffer Rendering with Material Graphs<a aria-label="Anchor link for: visibility-buffer-rendering-with-material-graphs" class=zola-anchor href=#visibility-buffer-rendering-with-material-graphs><i class="fas fa-link"></i></a></h3><p><a href=http://filmicworlds.com/blog/visibility-buffer-rendering-with-material-graphs/>http://filmicworlds.com/blog/visibility-buffer-rendering-with-material-graphs/</a><p>Great writing, great experiments and great numbers.<p>It presents a new rendering technique aside from forward rendering and deferred rendering. The visibility buffer rendering further breaks the second deferred rendering pass into two.<p>The most amazing part is that almost everything is done in compute shaders! Handwritten shader code for interpolation and texel fetching. As far as I know, the above two steps are done on hardware in GPUs. It means we can throw away part of the circuit on the GPU and still get almost the same performance doing rendering with this technique. That is AMAZING!!<p>As a graphics driver developer, I believe one day GPU(if they are still called this name) will have no hardware blocks for graphics pipelines and only having the compute pipelines. I think this algorithm will play a big role in our way towards that future.<p>Okay, forget about the above subjective opinions, when I was reading the quad utilization part. I am not convinced that it would affect performance much. Modern GPU runs more than 30 threads at once. So the low quad utilization for less than 30 or so pixels are no cost at all. However, the experiments shows that visibility buffer rendering performs much better than deferred rendering in high triangle per pixel cases. I am not sure if there are any other reasons outside of quad utilizations here.<p>The experiments only shows one material cases, though I suppose visibility buffer rendering will perform better with more materials. Doing everything in CS means far less PSO switches. And PSO switches are really a big performance killer in today's games.<h3 id=decoupled-visibility-multisampling>Decoupled Visibility Multisampling<a aria-label="Anchor link for: decoupled-visibility-multisampling" class=zola-anchor href=#decoupled-visibility-multisampling><i class="fas fa-link"></i></a></h3><p><a href=http://filmicworlds.com/blog/decoupled-visibility-multisampling/>http://filmicworlds.com/blog/decoupled-visibility-multisampling/</a><p>A follow up on the above article. Anti-aliasing in visibility buffer rendering. I don't understand the algorithm but it's nice to see it has a solution for aliasing.<h3 id=project-starline-feel-like-you-re-there-together>Project Starline: Feel like you're there, together<a aria-label="Anchor link for: project-starline-feel-like-you-re-there-together" class=zola-anchor href=#project-starline-feel-like-you-re-there-together><i class="fas fa-link"></i></a></h3><p><a href=https://blog.google/technology/research/project-starline/>https://blog.google/technology/research/project-starline/</a><p>So cool! Light field display from a device that looks like a normal monitor, I think it is cooler than the streaming and compression technique used here!!<p>I always wondering why light field rendering does not become a thing? For almost static scenes, we can do one offline light field rendering pass. Then with a query and sampling, we can get pretty realistic views efficiently. I think it is quite achievable in today's "cloud" world.<h3 id=on-leaving-california-and-the-silicon-valley>On leaving California and the Silicon Valley<a aria-label="Anchor link for: on-leaving-california-and-the-silicon-valley" class=zola-anchor href=#on-leaving-california-and-the-silicon-valley><i class="fas fa-link"></i></a></h3><p><a href=https://bartwronski.com/2021/06/28/on-leaving-california-and-the-silicon-valley/>https://bartwronski.com/2021/06/28/on-leaving-california-and-the-silicon-valley/</a><p>Haha, I don't like Cali either. But not because it lacks city life, but it has very poor natural sceneries(Bay area only, drive two hours gets you to Yosemite, that does not count). For example, I have been to Boulder, CO for a summer, it has far more approachable and better mountains (better than Yosemite). Countless mountains over 3000+ meters, some are even within 20 minutes walking distance. And at Boulder, there is a lot city life, too. I believe it is same with other middle states' small towns.<h3 id=naval-architecture>Naval Architecture<a aria-label="Anchor link for: naval-architecture" class=zola-anchor href=#naval-architecture><i class="fas fa-link"></i></a></h3><p><a href=https://ciechanow.ski/naval-architecture/>https://ciechanow.ski/naval-architecture/</a><p>To know something related to boat just for fun. The article is very approachable. The second half about propulsion is very interesting mathematically.<h3 id=programming-language-memory-models>Programming Language Memory Models<a aria-label="Anchor link for: programming-language-memory-models" class=zola-anchor href=#programming-language-memory-models><i class="fas fa-link"></i></a></h3><p><a href=https://research.swtch.com/plmm>https://research.swtch.com/plmm</a><p>I spent maybe two hours reading this, but I think it is really worth it. Memory model is hard, putting several memory models together makes it harder. I tried very hard to keep my mind thinking straight. The most surprising thing is that a non-coherent read/write is <strong>defined</strong> behavior in Java?! Okay, it does makes it much easier for finding bugs and debugging.<h3 id=anatomy-of-a-linux-dns-lookup>Anatomy of a Linux DNS Lookup<a aria-label="Anchor link for: anatomy-of-a-linux-dns-lookup" class=zola-anchor href=#anatomy-of-a-linux-dns-lookup><i class="fas fa-link"></i></a></h3><p><a href=https://zwischenzugs.com/2018/06/08/anatomy-of-a-linux-dns-lookup-part-i/>https://zwischenzugs.com/2018/06/08/anatomy-of-a-linux-dns-lookup-part-i/</a><p>I always get very confusing when setting up DNS at home. This serial of articles does a great job showing how DNS works from reading different configurations. DNS is really a weird design on Linux :(</section><footer><nav class="c-pagination p-pagination"><div class=c-pagination__ctrl><div class=c-pagination__newer></div><div class=c-pagination__older></div></div></nav></footer></article></main><footer class=l-footer><p class=p-copyright></footer>
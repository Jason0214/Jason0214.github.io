<!doctype html><html lang=en><head><meta charset=utf-8><meta content=no-referrer name=referrer><meta content="width=device-width,initial-scale=1.0,maximum-scale=5" name=viewport><title>Monitor Conntrack | Jiacheng's Mini Blog</title><meta content="Monitor Conntrack | Jiacheng's Mini Blog" property=og:title><meta content="Monitor Conntrack | Jiacheng's Mini Blog" name=twitter:title><meta content="Annoying Random Network Issue   After " a am away. bit. bruteforcely" but especially every feel few frequently, fully going happen hours, i in isn't issue it jitter last less may my name=description network obvious or random rebooted router seems streaming the to video week, when …"><meta content="Annoying Random Network Issue   After " a am away. bit. bruteforcely" but especially every feel few frequently, fully going happen hours, i in isn't issue it jitter last less may my network obvious or property=og:description random rebooted router seems streaming the to video week, when …"><meta content="Annoying Random Network Issue   After " a am away. bit. bruteforcely" but especially every feel few frequently, fully going happen hours, i in isn't issue it jitter last less may my name=twitter:description network obvious or random rebooted router seems streaming the to video week, when …"><meta content="Jiacheng's Mini Blog" property=og:site_name><meta content=https://jason0214.github.io property=og:url><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://jason0214.github.io/base.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=https://jason0214.github.io/fontawesome/fontawesome.css rel=stylesheet><link href=https://jason0214.github.io/fontawesome/brands.css rel=stylesheet><link href=https://jason0214.github.io/fontawesome/solid.css rel=stylesheet><link href=https://jason0214.github.io/favicon.ico rel=icon type=image/x-icon><body><a class="skip-link p-screen-reader-text" href=#main>Skip to content</a><header class=l-header><h1 class="c-title p-title"><a class=p-title__link href=https://jason0214.github.io>Jiacheng's Mini Blog</a></h1><p class=p-subtitle>Less tech, more life</header><main class=l-main id=main><article class=p-article><header><h1>Monitor Conntrack</h1><div><div class=c-time><time datetime=" 2026-01-17"> 2026-01-17 </time> - (5 min read)</div></div></header><section class=p-article__body id=js-article><h1 id=annoying-random-network-issue>Annoying Random Network Issue<a aria-label="Anchor link for: annoying-random-network-issue" class=zola-anchor href=#annoying-random-network-issue><i class="fas fa-link"></i></a></h1><p>After "bruteforcely" rebooted my router last week, the random network issue seems to happen less frequently, but isn't fully going away. Every few hours, I feel the network may jitter a bit. It is especially obvious when I am in video streaming or in an online meeting. I suspecting it is something with the ISP, but I don't have any clues.<h1 id=try-log-something>Try log something<a aria-label="Anchor link for: try-log-something" class=zola-anchor href=#try-log-something><i class="fas fa-link"></i></a></h1><p>Since I already have a semi-working monitoring on my router and connected it with a local hosted influxdb. I decided to at least log something from the router's network stack. Maybe I am able to inspect some changes in data the next time the "jitter" happens.<p>I only know a little bit about the network stack. After some Q&A with Gemini, I think the most simple, however, maybe useful thing to log is the <code>conntrack</code> states. It tells things of how many TCP connections my home devices are trying to open, how many connections are successfully established and running, and how many are seriously wrong, which are denoted by <code>new</code>, <code>established</code>, and <code>invalid</code> state value. These three states also exist in UDP, however, mean slightly different things. I am not yet sure about how to use <code>conntrack</code> stte to tell an ISP issue, or a router issue, or something else, though I assume tracking their trends is helpful.<p>I am going to add <code>2 (TCP / UDP) * 3 (Input / Output / Forward) * 3 (New / Established / Invalid) = 18</code> counters into the network stack using netfilters. I don't have IPv6 setup, so only IPv4 parts are concerned.<p>The netfilter rule are<pre style=color:#c0c5ce;background-color:#2b303b><code><span>table ip conntrack_stats
</span><span>flush table ip conntrack_stats
</span><span>
</span><span>table ip conntrack_stats {
</span><span>  # Conntrack counters
</span><span>  counter tcp_conntrack_fwd_new {}
</span><span>  counter tcp_conntrack_fwd_established {}
</span><span>  counter tcp_conntrack_fwd_invalid {}
</span><span>
</span><span>  counter tcp_conntrack_input_new {}
</span><span>  counter tcp_conntrack_input_established {}
</span><span>  counter tcp_conntrack_input_invalid {}
</span><span>
</span><span>  counter tcp_conntrack_output_new {}
</span><span>  counter tcp_conntrack_output_established {}
</span><span>  counter tcp_conntrack_output_invalid {}
</span><span>
</span><span>  counter udp_conntrack_fwd_new {}
</span><span>  counter udp_conntrack_fwd_established {}
</span><span>  counter udp_conntrack_fwd_invalid {}
</span><span>
</span><span>  counter udp_conntrack_input_new {}
</span><span>  counter udp_conntrack_input_established {}
</span><span>  counter udp_conntrack_input_invalid {}
</span><span>
</span><span>  counter udp_conntrack_output_new {}
</span><span>  counter udp_conntrack_output_established {}
</span><span>  counter udp_conntrack_output_invalid {}
</span><span>
</span><span>  chain input_counter {                                                                      
</span><span>      type filter hook input priority 0; policy accept;                             
</span><span>
</span><span>      ip protocol tcp ct state new         counter name "tcp_conntrack_input_new"                        
</span><span>      ip protocol tcp ct state established counter name "tcp_conntrack_input_established"                
</span><span>      ip protocol tcp ct state invalid     counter name "tcp_conntrack_input_invalid" 
</span><span>
</span><span>      ip protocol udp ct state new         counter name "udp_conntrack_input_new"                        
</span><span>      ip protocol udp ct state established counter name "udp_conntrack_input_established"                
</span><span>      ip protocol udp ct state invalid     counter name "udp_conntrack_input_invalid" 
</span><span>  }                                                                                  
</span><span>                                                                                       
</span><span>  chain output_counter {                                                                     
</span><span>      type filter hook output priority 0; policy accept;                            
</span><span>
</span><span>      ip protocol tcp ct state new         counter name "tcp_conntrack_output_new"                        
</span><span>      ip protocol tcp ct state established counter name "tcp_conntrack_output_established"                
</span><span>      ip protocol tcp ct state invalid     counter name "tcp_conntrack_output_invalid" 
</span><span>
</span><span>      ip protocol udp ct state new         counter name "udp_conntrack_output_new"                        
</span><span>      ip protocol udp ct state established counter name "udp_conntrack_output_established"                
</span><span>      ip protocol udp ct state invalid     counter name "udp_conntrack_output_invalid" 
</span><span>  }
</span><span>
</span><span>  chain forward_counter {
</span><span>      type filter hook forward priority 0; policy accept;
</span><span>
</span><span>      ip protocol tcp ct state new         counter name "tcp_conntrack_fwd_new"                        
</span><span>      ip protocol tcp ct state established counter name "tcp_conntrack_fwd_established"                
</span><span>      ip protocol tcp ct state invalid     counter name "tcp_conntrack_fwd_invalid" 
</span><span>
</span><span>      ip protocol udp ct state new         counter name "udp_conntrack_fwd_new"                        
</span><span>      ip protocol udp ct state established counter name "udp_conntrack_fwd_established"                
</span><span>      ip protocol udp ct state invalid     counter name "udp_conntrack_fwd_invalid"
</span><span>  } 
</span><span>}
</span></code></pre><ul><li>I wasn't entirely sure about the <code>priority</code> value. From Gemini (which I further confirmed), it has to belarger than <code>-200</code>, because that's where the <code>conntrack</code> state is assigned. In most of the cases, it does not need to be larger than <code>300</code> (meaning low priority) unless counters intended to track some Postrouting stats (which I do not fully understand the use case either). 99% of the time <code>0</code> is the good choice.</ul><p>Save the above rules into a file <code>conntrack-counter.nft</code> and load it using <code>nft -f conntrack-counter.nft</code>. These counters start to work immediately. They can be checked using <code>nft list counters table ip conntrack_stats</code>.<p>Example output:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>table ip conntrack_stats {
</span><span>	counter tcp_conntrack_fwd_new {
</span><span>		packets 13532 bytes 1214846
</span><span>	}
</span><span>	counter tcp_conntrack_fwd_established {
</span><span>		packets 1200992 bytes 3333665699
</span><span>	}
</span><span>	counter tcp_conntrack_fwd_invalid {
</span><span>		packets 1190 bytes 68329
</span><span>	}
</span><span>	counter tcp_conntrack_input_new {
</span><span>		packets 678 bytes 45204
</span><span>	}
</span><span>	counter tcp_conntrack_input_established {
</span><span>		packets 887356 bytes 1602155070
</span><span>	}
</span><span>	counter tcp_conntrack_input_invalid {
</span><span>		packets 137 bytes 5492
</span><span>	}
</span><span>	counter tcp_conntrack_output_new {
</span><span>		packets 989 bytes 59532
</span><span>	}
</span><span>	counter tcp_conntrack_output_established {
</span><span>		packets 702504 bytes 1596403186
</span><span>	}
</span><span>	counter tcp_conntrack_output_invalid {
</span><span>		packets 14 bytes 2337
</span><span>	}
</span><span>	counter udp_conntrack_fwd_new {
</span><span>		packets 25749 bytes 2838946
</span><span>	}
</span><span>	counter udp_conntrack_fwd_established {
</span><span>		packets 555574 bytes 401857503
</span><span>	}
</span><span>	counter udp_conntrack_fwd_invalid {
</span><span>		packets 0 bytes 0
</span><span>	}
</span><span>	counter udp_conntrack_input_new {
</span><span>		packets 19225 bytes 7102220
</span><span>	}
</span><span>	counter udp_conntrack_input_established {
</span><span>		packets 7816 bytes 2543315
</span><span>	}
</span><span>	counter udp_conntrack_input_invalid {
</span><span>		packets 0 bytes 0
</span><span>	}
</span><span>	counter udp_conntrack_output_new {
</span><span>		packets 6380 bytes 1153149
</span><span>	}
</span><span>	counter udp_conntrack_output_established {
</span><span>		packets 7193 bytes 2329245
</span><span>	}
</span><span>	counter udp_conntrack_output_invalid {
</span><span>		packets 0 bytes 0
</span><span>	}
</span><span>}
</span></code></pre><h1 id=get-counters-into-influxdb>Get counters into influxDB<a aria-label="Anchor link for: get-counters-into-influxdb" class=zola-anchor href=#get-counters-into-influxdb><i class="fas fa-link"></i></a></h1><p>I use <code>collectd</code> from OpenWrt/Luci to transmit router statistics to local hosted <code>telegraf</code> + <code>influxDB</code> instance. This setup could be a future blog post to share. Therefore, once the counters are populated to the <code>collectd</code>, they are automatically picked up by the <code>influxDB</code> and its dashboard.<p><code>Collectd</code> supports <code>Exec</code> plugin to run a shell script with its configured interval. This <code>Exec</code> plugin also has UI support on Luci. <img alt=collectd-settings-luci src=https://jason0214.github.io/monitor-conntrack/collectd-setting.jpg><p>I asked Gemini to code the script given the available nft counters, and I only need <code>packets</code>, not <code>bytes</code>. Gemini does it very well, much much better than me, with its complex <code>awk</code> scripting.<pre class=language-shell data-lang=shell style=color:#c0c5ce;background-color:#2b303b><code class=language-shell data-lang=shell><span>#!/bin/sh
</span><span># conntrack_counters_collectd.sh
</span><span>
</span><span>HOSTNAME="${COLLECTD_HOSTNAME:-localhost}"
</span><span>INTERVAL="${COLLECTD_INTERVAL:-60}"
</span><span>TABLE_NAME="conntrack_stats" 
</span><span>
</span><span># Add "nobody  ALL=(ALL) NOPASSWD: /usr/sbin/nft list counters *" to visudo
</span><span>
</span><span># We pass the variables inside the awk command string to avoid 'Unexpected token' errors 
</span><span># that sometimes occur with -v in specific BusyBox versions.
</span><span>sudo nft list counters table ip "$TABLE_NAME" | awk '
</span><span>/counter/ {
</span><span>    # Counter name is typically the 2nd field in "nft list counters"
</span><span>    name = $2;
</span><span>    gsub(/"/, "", name);
</span><span>}
</span><span>/packets/ {
</span><span>    # Find "packets" field index and print value
</span><span>    for (i=1; i&lt;=NF; i++) {
</span><span>        if ($i == "packets") {
</span><span>            # $(i+1) is the packet count
</span><span>            printf "PUTVAL \"%s/nftables-%s/packets-%s\" interval=%s N:%s\n", "'"$HOSTNAME"'", "'"$TABLE_NAME"'", name, "'"$INTERVAL"'", $(i+1);
</span><span>            break;
</span><span>        }
</span><span>    }
</span><span>}'
</span></code></pre><p>Due to the nice design of <code>collectd</code> that expects statistic to be output to <code>stdout</code> with <code>PUTVAL</code>. This script can be dry run standalone.<pre class=language-shell data-lang=shell style=color:#c0c5ce;background-color:#2b303b><code class=language-shell data-lang=shell><span>~/# ./conntrack_counters_collectd.sh 
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_fwd_new" interval=60 N:14243
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_fwd_established" interval=60 N:1238945
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_fwd_invalid" interval=60 N:1488
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_input_new" interval=60 N:723
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_input_established" interval=60 N:937001
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_input_invalid" interval=60 N:140
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_output_new" interval=60 N:1060
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_output_established" interval=60 N:749736
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-tcp_conntrack_output_invalid" interval=60 N:14
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_fwd_new" interval=60 N:28162
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_fwd_established" interval=60 N:573782
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_fwd_invalid" interval=60 N:0
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_input_new" interval=60 N:19752
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_input_established" interval=60 N:8233
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_input_invalid" interval=60 N:0
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_output_new" interval=60 N:6780
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_output_established" interval=60 N:7572
</span><span>PUTVAL "localhost/nftables-conntrack_stats/packets-udp_conntrack_output_invalid" interval=60 N:0
</span></code></pre><p>Add the script invocation to <code>Exec</code> Plugin from Luci UI, then everything is set. Though it would be nice to verify it using <code>logread</code>. If there are errors because of "Permission Denied". Do pay attention to <code># Add "nobody  ALL=(ALL) NOPASSWD: /usr/sbin/nft list counters *" to visudo</code><p>I have the <code>collectd</code> running interval with <code>30s</code>. It may not be sufficient enough to catch my issue, but I do have concerns on the storage cost if I increase the sampling more. I decide to use <code>30s</code> and wait and see.<h1 id=visualize-on-dashboard>Visualize on dashboard<a aria-label="Anchor link for: visualize-on-dashboard" class=zola-anchor href=#visualize-on-dashboard><i class="fas fa-link"></i></a></h1><p>By using the Cell and QueryBuilder from influxDB's dashboard. All the counters can be plotted. Example of <code>Established</code> looks like: <img alt=established-example src=https://jason0214.github.io/monitor-conntrack/example-established.jpg> It isn't very useful because the packet counts are accumulative, and don't change very frequenty. The plot looks like mostly a flat line.<p>I switch the QueryBuilder to ScriptBuilder and a <code>difference()</code><pre style=color:#c0c5ce;background-color:#2b303b><code><span>from(bucket: "home-lab-bucket")
</span><span>  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
</span><span>  |> filter(fn: (r) => r["_measurement"] == "nftables")
</span><span>  |> filter(fn: (r) => r["type_instance"] == "udp_conntrack_fwd_established" or r["type_instance"] == "tcp_conntrack_input_established" or r["type_instance"] == "tcp_conntrack_output_established" or r["type_instance"] == "udp_conntrack_input_established" or r["type_instance"] == "udp_conntrack_output_established" or r["type_instance"] == "tcp_conntrack_fwd_established")
</span><span>  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
</span><span>  |> difference()  # &lt;&lt;-- This is the only addition. Others are pre-created from QueryBuilder
</span><span>  |> yield(name: "mean")
</span></code></pre><p>Now the dashboard looks more "dynamic": <img alt=conntrack-full-example src=https://jason0214.github.io/monitor-conntrack/conntrack-full-example.jpg><p>I also added the <code>Invalid</code> conntrack specifically for my proxy connections. The whole transparent proxy setup is something interesting to share in a future blog post.<p>Now I will wait and see if it shows anything meaningful for the next potential network failure.<h1 id=watch-storage-cost>Watch storage cost<a aria-label="Anchor link for: watch-storage-cost" class=zola-anchor href=#watch-storage-cost><i class="fas fa-link"></i></a></h1><p>I host my influxDB on my Raspberry Pi's flash storage. I do have a slight concern on the additional storage cost after I adding 18 more counters. I would wish the cost isn't that much to not wear out the flash soon.<p>(I have another Cell on the dashboard to track Bucket write bandwidth, which runs:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>from(bucket: "self-metrics")
</span><span>  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
</span><span>  |> filter(fn: (r) => r["_measurement"] == "prometheus")
</span><span>  |> filter(fn: (r) => r["_field"] == "storage_shard_disk_size")
</span><span>  |> group(columns: ["bucket"])
</span><span>  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
</span><span>  |> difference()
</span><span>  |> yield(name: "mean")
</span></code></pre><p>and using a self scapper task <img alt=self-scrapper src=https://jason0214.github.io/monitor-conntrack/self-scrapper-task.jpg><pre style=color:#c0c5ce;background-color:#2b303b><code><span>import "experimental/prometheus"
</span><span>
</span><span>option task = {name: "InfluxDB Self-Scraper", every: 5m}
</span><span>
</span><span>prometheus.scrape(url: "http://localhost:8086/metrics")
</span><span>    |> filter(fn: (r) => r._field == "storage_shard_disk_size")
</span><span>    |> to(bucket: "self-metrics")
</span></code></pre><p>)<p>The write bandwidth does expectly increased a little bit after adding new counters, however, seems manageable. <img alt=storage-cost src=https://jason0214.github.io/monitor-conntrack/storage-cost.jpg></section><footer><nav class="c-pagination p-pagination"><div class=c-pagination__ctrl><div class=c-pagination__newer></div><div class=c-pagination__older></div></div></nav></footer></article></main><footer class=l-footer><p class=p-copyright></footer>